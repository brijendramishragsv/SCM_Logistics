# -*- coding: utf-8 -*-
"""Untitled17.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1auXQJPAKYmXP7B4jXTpd344J3qyH_C6Q
"""

import streamlit as st
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
import io

# --- CONFIGURATION ---
Y_VAR = 'Transport_Mode'
X_VARS = ['Route_ID', 'Supplier_Quality_Score', 'Cost_Per_Unit', 'Lead_Time_Days', 'Late_Delivery_Status']

def train_and_evaluate_model(X, Y, Y_labels):
    """Handles data splitting, model training, and evaluation."""

    # 3. Split Data
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.3, random_state=42)
    st.write(f"Training on {len(X_train)} samples, testing on {len(X_test)} samples.")

    # 4. Train Model
    st.subheader("Training Model...")
    with st.spinner("Training Random Forest Classifier..."):
        # Use a balanced class weight to handle potential class imbalance in transport modes
        model = RandomForestClassifier(n_estimators=200, random_state=42, class_weight='balanced')
        model.fit(X_train, Y_train)
    st.success("Random Forest Classifier trained successfully!")

    # 5. Evaluate Model
    st.header("Model Evaluation")
    Y_pred = model.predict(X_test)

    accuracy = accuracy_score(Y_test, Y_pred)
    st.metric("Model Accuracy on Test Set", f"{accuracy:.4f}")

    st.subheader("Classification Report")
    report = classification_report(Y_test, Y_pred, target_names=Y_labels.astype(str), output_dict=True)
    report_df = pd.DataFrame(report).transpose().round(4)
    st.dataframe(report_df)

    return model, X, Y_labels

def interactive_prediction(model, X_reference, Y_labels, unique_routes, data):
    """Creates the interactive prediction section."""
    st.header("Interactive Prediction")
    st.subheader("Input new data to predict Transport Mode")

    # Create input widgets
    col1, col2, col3 = st.columns(3)
    with col1:
        route_id = st.selectbox('Route ID', unique_routes)
        supplier_quality_score = st.slider('Supplier Quality Score',
                                           float(data['Supplier_Quality_Score'].min()),
                                           float(data['Supplier_Quality_Score'].max()),
                                           float(data['Supplier_Quality_Score'].median()),
                                           0.01)
    with col2:
        cost_per_unit = st.number_input('Cost Per Unit',
                                        value=float(data['Cost_Per_Unit'].median()),
                                        min_value=float(data['Cost_Per_Unit'].min()))
        lead_time_days = st.number_input('Lead Time Days',
                                         value=int(data['Lead_Time_Days'].median()),
                                         min_value=1, step=1)
    with col3:
        late_delivery_status = st.selectbox('Late Delivery Status', [0, 1], format_func=lambda x: 'Yes (1)' if x == 1 else 'No (0)')


    # Prepare input data for prediction
    input_data = pd.DataFrame({
        'Route_ID': [route_id],
        'Supplier_Quality_Score': [supplier_quality_score],
        'Cost_Per_Unit': [cost_per_unit],
        'Lead_Time_Days': [lead_time_days],
        'Late_Delivery_Status': [late_delivery_status]
    })

    # One-hot encode the new input, aligning with training data columns
    input_encoded = pd.get_dummies(input_data, columns=['Route_ID'], drop_first=True)

    # Find missing columns in input_encoded and add them (for routes not selected)
    missing_cols = set(X_reference.columns) - set(input_encoded.columns)

    # Add missing columns with value 0 and ensure the order of columns matches the training data
    for col in missing_cols:
        input_encoded[col] = 0

    # Must ensure column order matches the model's training data (X_reference)
    input_final = input_encoded[X_reference.columns]

    if st.button('Predict Transport Mode'):
        prediction_encoded = model.predict(input_final)
        predicted_mode = Y_labels[prediction_encoded[0]]
        st.success(f"The predicted **Transport Mode** is: **{predicted_mode}**")


def main():
    st.set_page_config(layout="wide")
    st.title("Logitech Supply Chain: Transport Mode Prediction")

    st.info(
        "Note: 'Transport_Mode' is a categorical variable, so this is a **Classification** "
        "problem, not Regression. The app uses a Random Forest Classifier to predict the transport mode."
    )

    st.header("1. Upload Data File")
    uploaded_file = st.file_uploader("Choose your CSV file (Brijendra Mishra - logitech_supply_chain.csv)", type="csv")

    if uploaded_file is not None:

        # Read the file content into a DataFrame
        data = pd.read_csv(uploaded_file)

        # Check if necessary columns exist
        missing_cols = [col for col in [Y_VAR] + X_VARS if col not in data.columns]
        if missing_cols:
            st.error(f"Error: The uploaded file is missing the following required columns: {', '.join(missing_cols)}")
            st.stop()

        # Display Data Overview
        st.header("2. Data Overview")
        st.dataframe(data.head())
        st.write(f"Predicting **{Y_VAR}** using features: **{', '.join(X_VARS)}**")

        # 3. Preprocessing and Feature Engineering
        st.header("3. Data Preprocessing")

        # Select relevant columns
        df = data[[Y_VAR] + X_VARS].copy()

        # Handle categorical features (Route_ID) using one-hot encoding
        df_processed = pd.get_dummies(df, columns=['Route_ID'], drop_first=True)

        # Align X and Y after encoding
        Y = df_processed[Y_VAR]
        X = df_processed.drop(columns=[Y_VAR])

        # Factorize Y to get numerical labels for classification
        Y_encoded, Y_labels = pd.factorize(Y)
        st.write(f"Target variable unique values: {Y_labels.tolist()}")

        # 4. Train, Evaluate, and Predict
        model, X_reference, Y_labels_ref = train_and_evaluate_model(X, Y_encoded, Y_labels)

        unique_routes = data['Route_ID'].unique().tolist()
        interactive_prediction(model, X_reference, Y_labels_ref, unique_routes, data)

if __name__ == '__main__':
    main()